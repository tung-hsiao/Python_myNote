# -*- coding: utf-8 -*-
"""opencv_test.ipynb

Automatically generated by Colaboratory.

"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# cv2.warpAffine
# cv2.getRotationMatrix2D
# cv2.getAffineTransform
# ================================
img_path = "/content/drive/MyDrive/Colab/image1.jpg"
img = cv2.imread(img_path, 1)
img = cv2.resize(img, (img.shape[1]//10, img.shape[0]//10), cv2.INTER_AREA)
rows, cols, channel = img.shape

# The usual way to represent an Affine Transformation is by using a 2Ã—3 matrix.
# M = [ a00x + a01y + b00,
#       a10x + a11y + b10 ]

# Translations
# cv2.warpAffine: input 2x3 matrix
M = np.float32([[1,0,100], [0,1,50]])
dst = cv2.warpAffine(img, M, (cols,rows))
cv2_imshow(dst)

# Rotating
center = (img.shape[1]//2, img.shape[0]//2)
angle = -50
scale = 0.6
M = cv2.getRotationMatrix2D(center, angle, scale)
dst = cv2.warpAffine(img, M, (cols,rows))
cv2_imshow(dst)

# getAffineTransform
pts1=np.float32([[50,50],[200,50],[50,200]])
pts2=np.float32([[60,60],[200,50],[50,200]])
M = cv2.getAffineTransform(pts1, pts2)
dst = cv2.warpAffine(img, M, (cols,rows))
cv2_imshow(dst)

# cv2.getPerspectiveTransform: need 4 points, output 3x3 matrix
# cv2.warpPerspective: input 3x3 matrix
pts1=np.float32([[50,50],[200,50],[50,200],[200,200]])
pts2=np.float32([[60,60],[200,50],[50,200],[200,200]])
M = cv2.getPerspectiveTransform(pts1, pts2)
dst = cv2.warpPerspective(img, M, (cols,rows))
cv2_imshow(dst)
